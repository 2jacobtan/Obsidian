---
created: 2021-05-29T00:45:56 (UTC +08:00)
tags: []
source: https://www.quora.com/What-is-your-review-of-Haskell-programming-language/review/Edward-Kmett
author: 
---

# Edward Kmett's answer to What is your review of Haskell (programming language)? - Quora

> ## Excerpt
> ★★★★★ Haskell is the reason I am still a programmer today. A decade ago I had a bit of a crisis of faith as a computer scientist. I looked around and realized that I was largely solving the same problems using variations on the same tools that I'd been working with several years prior. I'd somehow hit a wall, perhaps not as low as Erik Dietrick's Expert Beginner, but I'd definitely gotten to the point where even though I had been actively pursuing the construction of a large library of correct code that I could build atop, I found myself watching my sand-castles crumble as fast as I could erect them, and worse, I wasn't improving as a developer! There was No Silver Bullet in sight.  Object-oriented programming purports to give us code reuse but -- to borrow a term from Anthony Stafford Beer -- from a POSIWID (The purpose of a system is what it does) perspective, I found that the purpose of it was to get us to flog developers for not perfectly anticipating the precise level of abstraction that optimizes productivity and balances code reuse against specialization to the problem domain. In light of this, I decided to go back and collect degrees. Along the way, right after I finished my Master's in Math, and had drifted into Linguistics and Bioinformatics, I stumbled across Haskell. I'd been toying with writing my own programming language for 15 years or so by that point, and they all looked like the child of Perl, Python and C++ --  because those were what I knew -- with a dash of immutability thrown in. When I found Haskell I realized that here was a language that not only did all the things I was trying to do, but it did them better. The Haskell community simply had better answers than I did! At that point I was forced to make a choice. I could go back and hide my head in the sand, and pretend I never saw Haskell, or I could embrace it and make the ideas behind Haskell my own. The aftermath of this religious conversion took months to play out, but I've never looked back. Since then I've learned category theory. I've dived deep on functional programming and type theory, scaled up to work in Coq and Agda before coming back down to rest at the level of Haskell as the most productive power-to-weight ratio for my particular programming style.  Upon settling into the groove with Haskell, I've devoted my time to doing everything I can to help the Haskell community grow and thrive, and I've finally been able to start to achieve my goal of building an edifice of libraries that I can build atop. To put that in perspective, I believe I currently maintain more Haskell code than anyone, and I peaked somewhere around fifth most active user on github, just from writing Haskell. Alas, I've drifted down into the teens, as much of what I'm doing now is more focused on community outreach,  rather than simply writing packages. http://gist.github.com/paulmillr/2657075  Why Haskell? In a strict language, it is initially a bit easier to reason about the space and time usage of algorithms, but that superficial ease comes at a price. Compositions of strict algorithms often waste time computing all sorts of things you don't need. Consider a classic example: take 10 . sort In a strict language that will do all the work to sort the list, before I decide to only look at the first 10. But in a non-strict language like Haskell with lazy-by-default data structures, it'll only do the work to sort the first 10 elements. If your sort is the "lazy quicksort" or treesort that gets used in practice in Haskell, then this will silently upgrade you to a "quickselect" giving you better asymptotic performance. You get those asymptotic benefits without having to be smart enough and diligent enough to fuse together all the details of both algorithms by hand. In a strict setting you'd stop, notice the performance, and go off on a tangent to fix it up, sacrificing code reuse for speed or sacrificing speed for code reuse. I'd rather not be hoisted on the horns of that dilemma. Now, commonly the case is made that you could perhaps have written the algorithm in a lazy way in the strict setting, either through explicit lazy values or side-effects, but in practice people just don't do so, because frankly explicit laziness is too painful to use in the large. They try, they get frustrated, and then they stop. At best, you get a bit of code written with something like generators or streams instead. Another benefit of the Haskell approach are that not only do lazy algorithms compose better, but pure code admits trivial parallelization/incrementalization. This makes it a much easier affair to retrofit parallelism onto a working single threaded solution, whereas I live in fear that I forgot to handle the happens-before semantics properly, or missed a fence, etc. whenever I go to do that in other languages! A final factor that really made Haskell gel for me is the community. There are over 1200 users on the #haskell channel on irc.freenode.net, and yet it is a group of the most consistently nice, smart, people I know of anywhere on the internet. (https://gist.github.com/quchen/5280339).

---
★★★★★

Haskell is the reason I am still a programmer today.

A decade ago I had a bit of a crisis of faith as a computer scientist. I looked around and realized that I was largely solving the same problems using variations on the same tools that I'd been working with several years prior.

I'd somehow hit a wall, perhaps not as low as Erik Dietrick's [Expert Beginner](http://www.daedtech.com/how-developers-stop-learning-rise-of-the-expert-beginner "www.daedtech.com"), but I'd definitely gotten to the point where even though I had been actively pursuing the construction of a large library of correct code that I could build atop, I found myself watching my sand-castles crumble as fast as I could erect them, and worse, I wasn't improving as a developer! There was [No Silver Bullet](http://en.wikipedia.org/wiki/No_Silver_Bullet "en.wikipedia.org") in sight.

Object-oriented programming purports to give us code reuse but -- to borrow a term from Anthony Stafford Beer -- from a POSIWID ([The purpose of a system is what it does](http://en.wikipedia.org/wiki/The_purpose_of_a_system_is_what_it_does "en.wikipedia.org")) perspective, I found that the purpose of it was to get us to flog developers for not perfectly anticipating the precise level of abstraction that optimizes productivity and balances code reuse against specialization to the problem domain.

In light of this, I decided to go back and collect degrees. Along the way, right after I finished my Master's in Math, and had drifted into Linguistics and Bioinformatics, I stumbled across Haskell.

I'd been toying with writing my own programming language for 15 years or so by that point, and they all looked like the child of Perl, Python and C++ -- because those were what I knew -- with a dash of immutability thrown in. When I found Haskell I realized that here was a language that not only did all the things I was trying to do, but it did them better.

The Haskell community simply had better answers than I did!

At that point I was forced to make a choice. I could go back and hide my head in the sand, and pretend I never saw Haskell, or I could embrace it and make the ideas behind Haskell my own.

The aftermath of this religious conversion took months to play out, but I've never looked back.

Since then I've learned category theory. I've dived deep on functional programming and type theory, scaled up to work in Coq and Agda before coming back down to rest at the level of Haskell as the most productive power-to-weight ratio for my particular programming style.

Upon settling into the groove with Haskell, I've devoted my time to doing everything I can to help the Haskell community grow and thrive, and I've finally been able to start to achieve my goal of building an edifice of libraries that I can build atop. To put that in perspective, I believe I currently maintain more Haskell code than anyone, and I peaked somewhere around fifth most active user on github, just from writing Haskell. Alas, I've drifted down into the teens, as much of what I'm doing now is more focused on community outreach, rather than simply writing packages. [http://gist.github.com/paulmillr/2657075](http://gist.github.com/paulmillr/2657075 "gist.github.com")

Why Haskell?

In a strict language, it is initially a bit easier to reason about the space and time usage of algorithms, but that superficial ease comes at a price. Compositions of strict algorithms often waste time computing all sorts of things you don't need.

Consider a classic example: `take 10 . sort`

In a strict language that will do all the work to sort the list, before I decide to only look at the first 10. But in a non-strict language like Haskell with lazy-by-default data structures, it'll only do the work to sort the first 10 elements. If your sort is the "lazy quicksort" or treesort that gets used in practice in Haskell, then this will silently upgrade you to a "quickselect" giving you better asymptotic performance.

You get those asymptotic benefits without having to be smart enough and diligent enough to fuse together all the details of both algorithms by hand. In a strict setting you'd stop, notice the performance, and go off on a tangent to fix it up, sacrificing code reuse for speed or sacrificing speed for code reuse. I'd rather not be hoisted on the horns of that dilemma.

Now, commonly the case is made that you could perhaps have written the algorithm in a lazy way in the strict setting, either through explicit lazy values or side-effects, but in practice people just don't do so, because frankly explicit laziness is too painful to use in the large. They try, they get frustrated, and then they stop. At best, you get a bit of code written with something like generators or streams instead.

Another benefit of the Haskell approach are that not only do lazy algorithms compose better, but pure code admits trivial parallelization/incrementalization. This makes it a much easier affair to retrofit parallelism onto a working single threaded solution, whereas I live in fear that I forgot to handle the happens-before semantics properly, or missed a fence, etc. whenever I go to do that in other languages!

A final factor that really made Haskell gel for me is the community. There are over 1200 users on the `#haskell` channel on [irc.freenode.net](http://irc.freenode.net/ "irc.freenode.net"), and yet it is a group of the most consistently nice, smart, people I know of anywhere on the internet. ([https://gist.github.com/quchen/5280339](https://gist.github.com/quchen/5280339 "gist.github.com")).
